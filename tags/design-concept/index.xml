<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design Concept on Syed Zainulabideen</title>
    <link>https://syedzainulabideen.github.io/tags/design-concept/</link>
    <description>Recent content in Design Concept on Syed Zainulabideen</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 18 Aug 2023 19:30:00 +0500</lastBuildDate><atom:link href="https://syedzainulabideen.github.io/tags/design-concept/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SOLID - Dependency Inversion Principle (DIP)</title>
      <link>https://syedzainulabideen.github.io/posts/solid-dependency-inversion/</link>
      <pubDate>Fri, 18 Aug 2023 19:30:00 +0500</pubDate>
      
      <guid>https://syedzainulabideen.github.io/posts/solid-dependency-inversion/</guid>
      <description>The Dependency Inversion Principle (DIP) states that high-level modules should not depend on low-level modules. Both should depend on abstractions. By DIP we aimed to reduce coupling between high-level and low-level classes or components by introducing an abstraction layer between them.
So one can think, what does tight coupling or dependency between high and low level modules means? Let me explain, Tight coupling occurs when there is a strong, direct relationship between two modules.</description>
    </item>
    
    <item>
      <title>SOLID - Interface Segregation Principle (ISP)</title>
      <link>https://syedzainulabideen.github.io/posts/solid-interface-segregation/</link>
      <pubDate>Fri, 18 Aug 2023 09:30:00 +0500</pubDate>
      
      <guid>https://syedzainulabideen.github.io/posts/solid-interface-segregation/</guid>
      <description>ISP states that clients ( classes or modules that use an protocol ) should not be forced to depend on protocols they do not use. This implies that we need to structure our protocols or interfaces in a manner that precisely fulfills the requirements of the entities that adhere to them.
Let&amp;rsquo;s understand by a quick example. Suppose you have multiple payment methods available in your codebase.
// Protocol for processing payments protocol PaymentMethod { func processPayment(amount: Double) func refundPayment(amount: Double) } // Classes that implement the protocol class CreditCardPayment: PaymentMethod { func processPayment(amount: Double) { print(&amp;#34;Processing credit card payment of $\(amount)&amp;#34;) // Actual payment processing logic for credit card } func refundPayment(amount: Double) { print(&amp;#34;Refunding credit card payment of $\(amount)&amp;#34;) // Actual refund processing logic for credit card } } class PayPalPayment: PaymentMethod { func processPayment(amount: Double) { print(&amp;#34;Processing PayPal payment of $\(amount)&amp;#34;) // Actual payment processing logic for PayPal } func refundPayment(amount: Double) { /* Imagine a scenario where there&amp;#39;s no refund policy applicable to PayPal transactions.</description>
    </item>
    
    <item>
      <title>SOLID: Liskov Substitution Principle (LSP)</title>
      <link>https://syedzainulabideen.github.io/posts/solid-liskov-substitution/</link>
      <pubDate>Thu, 17 Aug 2023 09:25:00 +0500</pubDate>
      
      <guid>https://syedzainulabideen.github.io/posts/solid-liskov-substitution/</guid>
      <description>LSP states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.
Subclasses should preserve the core functionalities provided by the Super classes and should not override or change them. Also subclasses should adhere the rules or contracts defined by the Super classes like method signatures, preconditions, postconditions etc.
So let&amp;rsquo;s take an example to show how code can violate the LSP.</description>
    </item>
    
    <item>
      <title>SOLID - Open Close Principle (OCP)</title>
      <link>https://syedzainulabideen.github.io/posts/solid-open-close/</link>
      <pubDate>Wed, 16 Aug 2023 09:36:00 +0500</pubDate>
      
      <guid>https://syedzainulabideen.github.io/posts/solid-open-close/</guid>
      <description>OCP states that software entities (such as classes, modules, functions, etc.) should be open for extension but closed for modification. In simple words it means that once a entity is created and working as intended, its internal code should not be modified to add new features or behaviors.
So how can then we add features or update the functionalities? And the answer is by extending the existing entities with by Subclassing, Extensions or Protocols/Interfaces etc.</description>
    </item>
    
    <item>
      <title>SOLID - Single Responsibility Principle (SRP)</title>
      <link>https://syedzainulabideen.github.io/posts/solid-single-responsibility/</link>
      <pubDate>Tue, 15 Aug 2023 10:20:00 +0500</pubDate>
      
      <guid>https://syedzainulabideen.github.io/posts/solid-single-responsibility/</guid>
      <description>SRP states that a class should have only one reason to change or only one responsibility. In other words, a class should have a single, well-defined purpose.
Let&amp;rsquo;s understand this concept with a quick example. Suppose we have a User class and also there are two functioanlities accociated with this class i.e. saveToDatabase and sendWelcomeEmail.
Now condier the below code snippet that&amp;rsquo;s without the usage of SRP principle. We embedded the two functionality right into the User class.</description>
    </item>
    
  </channel>
</rss>
